<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>POM Flip ‚Äî PvP Betting</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script type="module" src="./ton-utils.js"></script>
  <style>
  :root{
    --bg:#0b0f1a; --card:#121830; --ink:#e8f1ff; --muted:#a9b8ff;
    --btn:#1b2243; --btn2:#16203c; --ok:#0fd17b; --warn:#ffb65e;
    --ring: rgba(110,227,255,.25); --pom:#ff6b35; --gold:#ffd700;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    background:var(--bg); color:var(--ink); display:flex; align-items:center; justify-content:center;
    padding:16px; -webkit-tap-highlight-color: transparent;
  }
  .wrap{ width:100%; max-width:420px; }
  .head{ text-align:center; margin-bottom:10px; }
  .title{ font-weight:800; font-size:18px; letter-spacing:.2px; }
  .sub{ color:var(--muted); font-size:13px; margin-top:4px; }
  .card{
    background:var(--card); border:1px solid rgba(110,227,255,.15);
    border-radius:16px; padding:14px 14px 12px;
  }

  /* Mode Selection */
  .mode-selector{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:16px; }
  .mode-btn{ 
    padding:12px; border:none; border-radius:12px; font-weight:700; font-size:14px;
    background:var(--btn); color:var(--ink); cursor:pointer; transition:all 0.2s;
  }
  .mode-btn.active{ background:var(--pom); color:#fff; }
  .mode-btn:hover{ filter:brightness(1.1); }

  /* PvP Interface */
  .pvp-section{ display:none; }
  .pvp-section.active{ display:block; }
  
  .bet-selector{ margin:12px 0; }
  .bet-amounts{ display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-bottom:10px; }
  .bet-btn{
    padding:10px; border:none; border-radius:8px; font-weight:700; font-size:13px;
    background:var(--btn2); color:var(--ink); cursor:pointer; transition:all 0.2s;
  }
  .bet-btn.active{ background:var(--pom); color:#fff; }
  .bet-btn:hover{ filter:brightness(1.1); }
  
  .pom-balance{ 
    text-align:center; margin:8px 0; padding:8px; background:rgba(255,107,53,.1);
    border-radius:8px; border:1px solid var(--pom); color:var(--pom); font-weight:700;
  }

  /* Game Room */
  .game-room{ display:none; }
  .game-room.active{ display:block; }
  
  .players{ display:flex; justify-content:space-between; margin:12px 0; }
  .player{ text-align:center; flex:1; }
  .player-name{ font-weight:700; font-size:14px; }
  .player-bet{ color:var(--pom); font-size:12px; margin-top:2px; }
  .player-choice{ margin-top:8px; font-size:20px; }
  
  .vs{ display:flex; align-items:center; justify-content:center; font-size:24px; font-weight:800; color:var(--muted); }

  /* Coin */
  .stage{ perspective:1000px; display:flex; justify-content:center; margin:6px 0 10px; }
  .coin{
    width:132px; height:132px; border-radius:50%;
    position:relative; transform-style:preserve-3d;
    background: radial-gradient(65% 50% at 50% 35%, #1d2752 0%, #0f1531 70%);
    box-shadow: inset 0 0 18px rgba(255,255,255,.06), 0 10px 28px rgba(0,0,0,.35);
    border:1px solid var(--ring);
    transition: transform 900ms cubic-bezier(.22,.8,.2,1);
  }
  .coin::before{ content:""; position:absolute; inset:8px; border-radius:50%; border:1px dashed var(--ring); }
  .face{ position:absolute; inset:0; display:grid; place-items:center; font-size:44px; backface-visibility:hidden; user-select:none; }
  .front{ transform: translateZ(2px); }
  .back { transform: rotateY(180deg) translateZ(2px); }

  .buttons{ display:grid; gap:10px; margin-top:8px; }
  button{
    height:54px; border:none; border-radius:12px; font-weight:800; font-size:16px; letter-spacing:.2px;
    background:var(--btn); color:#eaf3ff; box-shadow:0 6px 16px rgba(0,0,0,.24);
    display:flex; align-items:center; justify-content:center; gap:8px; cursor:pointer;
  }
  .b2{ background:var(--btn2); }
  button:active{ transform:translateY(1px) }
  button[disabled]{ opacity:.6; cursor:not-allowed; }

  .info{
    margin-top:10px; display:flex; justify-content:space-between; font-size:13px; color:var(--muted);
  }
  .toast{
    position:fixed; left:16px; right:16px; bottom: max(16px, env(safe-area-inset-bottom));
    background:#0e1430; color:#dff6ff; border:1px solid rgba(110,227,255,.18);
    border-radius:12px; padding:10px 12px; font-weight:700; text-align:center; opacity:0; transform:translateY(8px);
    transition:opacity .18s ease, transform .18s ease;
  }
  .toast.show{ opacity:1; transform:translateY(0) }
  .ok{ color:var(--ok) } .warn{ color:var(--warn) } .pom{ color:var(--pom) }
  
  /* Match List Styles */
  .match-item{
    display:flex; align-items:center; padding:12px; margin-bottom:8px;
    background:var(--btn2); border-radius:10px; border:1px solid rgba(110,227,255,.1);
    transition:all 0.2s;
  }
  .match-item:hover{ background:var(--btn); transform:translateY(-1px); }
  .match-rounds{ 
    width:40px; height:40px; border-radius:50%; display:flex; align-items:center; justify-content:center;
    background:var(--pom); color:#fff; font-weight:800; font-size:14px; margin-right:12px;
  }
  .match-bet{ 
    flex:1; display:flex; align-items:center; gap:8px;
  }
  .bet-amount{ font-weight:700; color:var(--pom); }
  .match-players{ 
    display:flex; align-items:center; gap:4px; margin-right:12px;
  }
  .player-slot{ 
    width:24px; height:24px; border-radius:50%; display:flex; align-items:center; justify-content:center;
    background:var(--ok); color:#fff; font-size:12px; font-weight:700;
  }
  .player-slot.empty{ background:var(--muted); }
  .match-actions{ display:flex; gap:6px; }
  .action-btn{ 
    padding:6px 10px; border:none; border-radius:6px; font-size:11px; font-weight:700; cursor:pointer;
    background:var(--btn); color:var(--ink); transition:all 0.2s;
  }
  .action-btn.primary{ background:var(--pom); color:#fff; }
  .action-btn:hover{ filter:brightness(1.1); }
  
  footer{ margin-top:10px; text-align:center; color:var(--muted); font-size:12px; opacity:.9 }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="head">
      <div class="title">POM Flip PvP</div>
      <div class="sub">Heads = Bark üêï ¬∑ Tails = Bite ü¶¥</div>
    </div>

    <!-- Mode Selection -->
    <div class="mode-selector">
      <button class="mode-btn active" onclick="setMode('solo')">Solo</button>
      <button class="mode-btn" onclick="setMode('pvp')">PvP Local</button>
      <button class="mode-btn" onclick="setMode('onchain')">PvP On-Chain</button>
    </div>

    <!-- Solo Mode -->
    <div id="soloMode" class="card">
      <div class="stage">
        <div id="coin" class="coin" aria-live="polite">
          <div class="face front" aria-label="Heads">üêï</div>
          <div class="face back" aria-label="Tails">ü¶¥</div>
        </div>
      </div>

      <div class="buttons">
        <button id="btnH">Heads (Bark üêï)</button>
        <button id="btnT" class="b2">Tails (Bite ü¶¥)</button>
      </div>

      <div class="info">
        <div id="score">Score: 0</div>
        <div id="streak">Streak: 0 üî•</div>
      </div>
    </div>

    <!-- PvP Mode -->
    <div id="pvpMode" class="pvp-section">
      <div class="card">
        <div class="pom-balance">
          üí∞ POM Balance: <span id="pomBalance">1000</span> POM
        </div>
        
        <!-- Match List Header -->
        <div style="display:flex; justify-content:space-between; align-items:center; margin:16px 0 12px;">
          <h3 style="margin:0; font-size:16px; font-weight:700;">üéÆ Matchs Actifs</h3>
          <button onclick="showCreateMatch()" style="padding:8px 12px; background:var(--pom); color:#fff; border:none; border-radius:6px; font-weight:700; font-size:12px; cursor:pointer;">
            ‚ûï Cr√©er
          </button>
        </div>

        <!-- Search Bar -->
        <div style="margin-bottom:12px;">
          <input type="text" id="matchSearch" placeholder="üîç Rechercher un match..." style="width:100%; padding:10px; border:none; border-radius:8px; background:var(--btn2); color:var(--ink); font-size:14px;">
        </div>

        <!-- Match List -->
        <div id="matchList" style="max-height:300px; overflow-y:auto;">
          <!-- Matches will be populated here -->
        </div>

        <!-- Create Match Interface -->
        <div id="createMatchInterface" style="display:none;">
          <div style="text-align:center; margin-bottom:16px; font-weight:700; color:var(--pom);">
            üéÆ Cr√©er un Match
          </div>
          
          <div class="bet-selector">
            <div style="font-size:14px; font-weight:700; margin-bottom:8px;">Mise (POM):</div>
            <div class="bet-amounts">
              <button class="bet-btn" onclick="setCreateBet(10)">10 POM</button>
              <button class="bet-btn" onclick="setCreateBet(50)">50 POM</button>
              <button class="bet-btn" onclick="setCreateBet(100)">100 POM</button>
              <button class="bet-btn" onclick="setCreateBet(250)">250 POM</button>
              <button class="bet-btn" onclick="setCreateBet(500)">500 POM</button>
              <button class="bet-btn" onclick="setCreateBet(1000)">1000 POM</button>
            </div>
          </div>

          <div class="buttons">
            <button onclick="createNewMatch()">üöÄ Cr√©er le Match</button>
            <button onclick="hideCreateMatch()" class="b2">‚ùå Annuler</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Game Room -->
    <div id="gameRoom" class="game-room">
      <div class="card">
        <div class="players">
          <div class="player">
            <div class="player-name" id="player1Name">Vous</div>
            <div class="player-bet" id="player1Bet">0 POM</div>
            <div class="player-choice" id="player1Choice">‚Äî</div>
          </div>
          <div class="vs">VS</div>
          <div class="player">
            <div class="player-name" id="player2Name">Adversaire</div>
            <div class="player-bet" id="player2Bet">0 POM</div>
            <div class="player-choice" id="player2Choice">‚Äî</div>
          </div>
        </div>

        <div class="stage">
          <div id="pvpCoin" class="coin" aria-live="polite">
            <div class="face front" aria-label="Heads">üêï</div>
            <div class="face back" aria-label="Tails">ü¶¥</div>
          </div>
        </div>

        <div class="buttons">
          <button id="pvpBtnH" onclick="makeChoice('heads')">Heads (Bark üêï)</button>
          <button id="pvpBtnT" class="b2" onclick="makeChoice('tails')">Tails (Bite ü¶¥)</button>
        </div>

        <div id="gameStatus" style="text-align:center; margin-top:10px; font-weight:700; color:var(--muted);">
          En attente d'un adversaire...
        </div>
      </div>
    </div>

    <!-- On-Chain Mode -->
    <div id="onchainMode" class="pvp-section">
  <div class="card">
        <div id="walletStatus" style="text-align:center; margin-bottom:16px; padding:12px; background:rgba(255,107,53,.1); border-radius:8px; border:1px solid var(--pom);">
          <div id="walletAddress" style="color:var(--pom); font-weight:700;">Connectez votre wallet TON</div>
          <button id="connectWallet" onclick="connectTONWallet()" style="margin-top:8px; padding:8px 16px; background:var(--pom); color:#fff; border:none; border-radius:6px; font-weight:700; cursor:pointer;">
            üîó Connecter Wallet
          </button>
        </div>
        
        <div id="onchainBetSelector" style="display:none;">
          <div class="pom-balance">
            üí∞ TON Balance: <span id="tonBalance">0</span> TON
          </div>
          
          <div class="bet-selector">
            <div style="font-size:14px; font-weight:700; margin-bottom:8px;">Mise (TON):</div>
            <div class="bet-amounts">
              <button class="bet-btn" onclick="setOnchainBet(0.01)">0.01 TON</button>
              <button class="bet-btn" onclick="setOnchainBet(0.05)">0.05 TON</button>
              <button class="bet-btn" onclick="setOnchainBet(0.1)">0.1 TON</button>
              <button class="bet-btn" onclick="setOnchainBet(0.5)">0.5 TON</button>
              <button class="bet-btn" onclick="setOnchainBet(1)">1 TON</button>
              <button class="bet-btn" onclick="setOnchainBet(5)">5 TON</button>
            </div>
          </div>

          <div class="buttons">
            <button id="createOnchainMatch" onclick="createOnchainMatch()">üéÆ Cr√©er un match</button>
            <button id="joinOnchainMatch" onclick="showJoinInterface()">üîç Rejoindre un match</button>
          </div>
        </div>

        <div id="joinInterface" style="display:none;">
          <div style="margin-bottom:12px;">
            <input type="number" id="matchIdInput" placeholder="ID du match" style="width:100%; padding:12px; border:none; border-radius:8px; background:var(--btn2); color:var(--ink); font-size:16px;">
          </div>
          <div class="buttons">
            <button onclick="joinOnchainMatch()">üöÄ Rejoindre</button>
            <button onclick="hideJoinInterface()" class="b2">‚ùå Annuler</button>
          </div>
        </div>

        <div id="onchainGameRoom" style="display:none;">
          <div style="text-align:center; margin-bottom:12px; font-weight:700; color:var(--pom);">
            Match #<span id="currentMatchId">0</span>
          </div>
          
          <div class="players">
            <div class="player">
              <div class="player-name" id="onchainPlayer1">Vous</div>
              <div class="player-bet" id="onchainBet1">0 TON</div>
              <div class="player-choice" id="onchainChoice1">‚Äî</div>
            </div>
            <div class="vs">VS</div>
            <div class="player">
              <div class="player-name" id="onchainPlayer2">Adversaire</div>
              <div class="player-bet" id="onchainBet2">0 TON</div>
              <div class="player-choice" id="onchainChoice2">‚Äî</div>
            </div>
          </div>

          <div class="stage">
            <div id="onchainCoin" class="coin" aria-live="polite">
              <div class="face front" aria-label="Heads">üêï</div>
              <div class="face back" aria-label="Tails">ü¶¥</div>
            </div>
          </div>

          <div class="buttons">
            <button id="onchainBtnH" onclick="makeOnchainChoice('heads')">Heads (Bark üêï)</button>
            <button id="onchainBtnT" class="b2" onclick="makeOnchainChoice('tails')">Tails (Bite ü¶¥)</button>
          </div>

          <div id="onchainStatus" style="text-align:center; margin-top:10px; font-weight:700; color:var(--muted);">
            En attente...
          </div>

          <div class="buttons" style="margin-top:12px;">
            <button onclick="revealOnchainSeed()" id="revealBtn" style="display:none;">üîì R√©v√©ler</button>
            <button onclick="cancelOnchainMatch()" id="cancelBtn" style="display:none;">‚ùå Annuler</button>
            <button onclick="claimOnchainForfeit()" id="claimBtn" style="display:none;">üí∞ R√©cup√©rer</button>
          </div>
        </div>
      </div>
    </div>

    <footer>POM Flip PvP ‚Ä¢ Misez vos POM et gagnez! ‚Ä¢ v2.0</footer>
  </div>

  <div id="toast" class="toast">‚Äî</div>

  <script>
  // --- Telegram integration ---
  const tg = window.Telegram?.WebApp;
  if (tg){ tg.ready(); tg.expand(); }
  const haptic = (t='light')=>{ try{ tg?.HapticFeedback?.impactOccurred(t) }catch(e){} };

  // --- Game State ---
  let currentMode = 'solo';
  let currentBet = 0;
  let pomBalance = parseInt(localStorage.getItem('pom_balance') || '1000', 10);
  let gameState = 'waiting'; // waiting, choosing, flipping, result
  let myChoice = null;
  let opponentChoice = null;
  let gameResult = null;

  // --- Solo Mode Variables ---
  let score = parseInt(localStorage.getItem('pomflip_score')||'0',10);
  let day = localStorage.getItem('pomflip_day')||'';
  let streak = parseInt(localStorage.getItem('pomflip_streak')||'0',10);
  let busy = false;
  let spinIndex = 0;
  let pending = null;

  // --- Elements ---
  const coin = document.getElementById('coin');
  const btnH = document.getElementById('btnH');
  const btnT = document.getElementById('btnT');
    const scoreEl = document.getElementById('score');
  const streakEl = document.getElementById('streak');
  const toast = document.getElementById('toast');
  const pomBalanceEl = document.getElementById('pomBalance');

  // --- Mode Management ---
  function setMode(mode) {
    currentMode = mode;
    document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    
    document.getElementById('soloMode').style.display = mode === 'solo' ? 'block' : 'none';
    document.getElementById('pvpMode').style.display = mode === 'pvp' ? 'block' : 'none';
    document.getElementById('onchainMode').style.display = mode === 'onchain' ? 'block' : 'none';
    document.getElementById('gameRoom').classList.toggle('active', false);
    
    if (mode === 'pvp') {
      updatePomBalance();
      initializeMatches();
    } else if (mode === 'onchain') {
      checkWalletConnection();
    }
  }

  // --- PvP Match System ---
  let activeMatches = [];
  let createBet = 0;

  // Initialize with some sample matches
  function initializeMatches() {
    activeMatches = [
      { id: 1, bet: 50, players: 1, maxPlayers: 2, creator: "Player1", status: "waiting" },
      { id: 2, bet: 100, players: 2, maxPlayers: 2, creator: "Player2", status: "full" },
      { id: 3, bet: 250, players: 1, maxPlayers: 2, creator: "Player3", status: "waiting" },
      { id: 4, bet: 500, players: 1, maxPlayers: 2, creator: "Player4", status: "waiting" },
      { id: 5, bet: 1000, players: 2, maxPlayers: 2, creator: "Player5", status: "full" }
    ];
    renderMatchList();
  }

  function renderMatchList() {
    const matchList = document.getElementById('matchList');
    const searchTerm = document.getElementById('matchSearch').value.toLowerCase();
    
    const filteredMatches = activeMatches.filter(match => 
      match.bet.toString().includes(searchTerm) || 
      match.creator.toLowerCase().includes(searchTerm)
    );

    matchList.innerHTML = filteredMatches.map(match => `
      <div class="match-item">
        <div class="match-rounds">${match.players}/${match.maxPlayers}</div>
        <div class="match-bet">
          <span class="bet-amount">${match.bet} POM</span>
        </div>
        <div class="match-players">
          ${Array.from({length: match.maxPlayers}, (_, i) => 
            `<div class="player-slot ${i < match.players ? '' : 'empty'}">${i < match.players ? 'üë§' : '+'}</div>`
          ).join('')}
        </div>
        <div class="match-actions">
          <button class="action-btn" onclick="watchMatch(${match.id})">üëÅÔ∏è Regarder</button>
          ${match.status === 'waiting' ? 
            `<button class="action-btn primary" onclick="joinMatch(${match.id})">üöÄ Rejoindre</button>` :
            `<button class="action-btn" disabled>Complet</button>`
          }
        </div>
      </div>
    `).join('');
  }

  function showCreateMatch() {
    document.getElementById('createMatchInterface').style.display = 'block';
    document.getElementById('matchList').style.display = 'none';
    document.getElementById('matchSearch').style.display = 'none';
  }

  function hideCreateMatch() {
    document.getElementById('createMatchInterface').style.display = 'none';
    document.getElementById('matchList').style.display = 'block';
    document.getElementById('matchSearch').style.display = 'block';
  }

  function setCreateBet(amount) {
    if (amount > pomBalance) {
      toastMsg('üí∞ Pas assez de POM!', 'warn');
      return;
    }
    createBet = amount;
    document.querySelectorAll('#createMatchInterface .bet-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    toastMsg(`Mise: ${amount} POM`, 'pom');
  }

  function createNewMatch() {
    if (createBet === 0) {
      toastMsg('üí∞ Choisissez une mise d\'abord!', 'warn');
      return;
    }

    const newMatch = {
      id: Date.now(),
      bet: createBet,
      players: 1,
      maxPlayers: 2,
      creator: "Vous",
      status: "waiting"
    };

    activeMatches.unshift(newMatch);
    renderMatchList();
    hideCreateMatch();
    
    toastMsg(`üéÆ Match cr√©√©! Mise: ${createBet} POM`, 'ok');
    haptic('medium');
  }

  function joinMatch(matchId) {
    const match = activeMatches.find(m => m.id === matchId);
    if (!match || match.status !== 'waiting') {
      toastMsg('‚ùå Match non disponible', 'warn');
      return;
    }

    if (match.bet > pomBalance) {
      toastMsg('üí∞ Pas assez de POM pour rejoindre!', 'warn');
      return;
    }

    // Simulate joining
    match.players++;
    match.status = match.players >= match.maxPlayers ? 'full' : 'waiting';
    
    renderMatchList();
    toastMsg(`üöÄ Match rejoint! Mise: ${match.bet} POM`, 'ok');
    
    // Start the game
    setTimeout(() => {
      startPvPGame(match);
    }, 1000);
  }

  function watchMatch(matchId) {
    const match = activeMatches.find(m => m.id === matchId);
    if (match) {
      toastMsg(`üëÅÔ∏è Observation du match ${matchId}`, '');
      // In a real app, you'd show the match in spectator mode
    }
  }

  function startPvPGame(match) {
    document.getElementById('pvpMode').style.display = 'none';
    document.getElementById('gameRoom').classList.add('active');
    
    // Simuler un adversaire
    const opponentName = `Player${Math.floor(Math.random() * 1000)}`;
    document.getElementById('player1Bet').textContent = `${match.bet} POM`;
    document.getElementById('player2Bet').textContent = `${match.bet} POM`;
    document.getElementById('player2Name').textContent = opponentName;
    document.getElementById('gameStatus').textContent = 'Choisissez votre c√¥t√©!';
    
    gameState = 'choosing';
    haptic('medium');
    toastMsg(`üéÆ Match d√©marr√©! Mise: ${match.bet} POM`, 'ok');
  }

  function makeChoice(choice) {
    if (gameState !== 'choosing') return;
    
    myChoice = choice;
    document.getElementById('player1Choice').textContent = choice === 'heads' ? 'üêï' : 'ü¶¥';
    document.getElementById('pvpBtnH').disabled = true;
    document.getElementById('pvpBtnT').disabled = true;
    
    // Simuler le choix de l'adversaire
    setTimeout(() => {
      opponentChoice = Math.random() < 0.5 ? 'heads' : 'tails';
      document.getElementById('player2Choice').textContent = opponentChoice === 'heads' ? 'üêï' : 'ü¶¥';
      document.getElementById('gameStatus').textContent = 'Lancement de la pi√®ce...';
      
      setTimeout(() => {
        flipPvPCoin();
      }, 1000);
    }, 1500);
    
    haptic('light');
  }

  function flipPvPCoin() {
    gameState = 'flipping';
      const outcome = Math.random() < 0.5 ? 'heads' : 'tails';
    
    // Animation de la pi√®ce
    const pvpCoin = document.getElementById('pvpCoin');
    spinIndex++;
    const baseTurns = 2 + Math.floor(Math.random()*2);
    const tilt = (Math.random()*10 - 5);
    const finalRotation = outcome === 'tails' ? 180 : 0;
    const deg = baseTurns*180 + finalRotation + spinIndex*360;
    
    pvpCoin.style.transition = 'transform 900ms cubic-bezier(.22,.8,.2,1)';
    void pvpCoin.offsetWidth;
    pvpCoin.style.transform = `rotateY(${deg}deg) rotateZ(${tilt}deg)`;
    
    // R√©sultat apr√®s animation
    pvpCoin.addEventListener('transitionend', function resultHandler(e) {
      if (e.propertyName !== 'transform') return;
      pvpCoin.removeEventListener('transitionend', resultHandler);
      
      const iWon = (myChoice === outcome);
      const result = iWon ? 'VICTOIRE!' : 'D√âFAITE';
      const color = iWon ? 'ok' : 'warn';
      
      if (iWon) {
        pomBalance += currentBet * 2; // Gagne le double de la mise
        haptic('heavy');
        toastMsg(`üéâ ${result}! +${currentBet * 2} POM`, 'ok');
      } else {
        pomBalance -= currentBet; // Perd la mise
        haptic('light');
        toastMsg(`üòî ${result}! -${currentBet} POM`, 'warn');
      }
      
      document.getElementById('gameStatus').textContent = `${result} - ${outcome === 'heads' ? 'HEADS' : 'TAILS'}`;
      updatePomBalance();
      savePomBalance();
      
      // Retour au menu apr√®s 3 secondes
      setTimeout(() => {
        document.getElementById('gameRoom').classList.remove('active');
        document.getElementById('pvpMode').style.display = 'block';
        resetPvPGame();
      }, 3000);
    });
  }

  function resetPvPGame() {
    gameState = 'waiting';
    myChoice = null;
    opponentChoice = null;
    document.getElementById('player1Choice').textContent = '‚Äî';
    document.getElementById('player2Choice').textContent = '‚Äî';
    document.getElementById('pvpBtnH').disabled = false;
    document.getElementById('pvpBtnT').disabled = false;
    document.getElementById('gameStatus').textContent = 'En attente d\'un adversaire...';
  }

  function updatePomBalance() {
    pomBalanceEl.textContent = pomBalance;
  }

  function savePomBalance() {
    localStorage.setItem('pom_balance', String(pomBalance));
  }

  // --- Solo Mode Functions (existing) ---
  function today(){
    const d=new Date(); return `${d.getFullYear()}-${d.getMonth()+1}-${d.getDate()}`;
  }
  function save(){
    localStorage.setItem('pomflip_score', String(score));
    localStorage.setItem('pomflip_streak', String(streak));
    localStorage.setItem('pomflip_day', day);
  }
  function hud(){
    scoreEl.textContent = `Score: ${score}`;
    streakEl.textContent = `Streak: ${streak} üî•`;
    save();
  }

  // daily bonus (1pt/jour) + streak
  const t = today();
  if (day !== t){
    streak = day ? streak + 1 : 1;
    day = t;
    score += 1;
    hud();
    toastMsg(`üéÅ Bonus quotidien +1 pt (streak ${streak})`);
  } else {
    hud();
  }

  function toastMsg(txt, cls=''){
    toast.className = `toast ${cls} show`;
    toast.textContent = txt;
    setTimeout(()=>toast.classList.remove('show'), 1200);
  }
  function setBusy(v){ busy=v; btnH.disabled=v; btnT.disabled=v; }

  function spinTo(finalSide){ // 'heads' | 'tails'
    spinIndex++;
    const baseTurns = 2 + Math.floor(Math.random()*2);
    const tilt = (Math.random()*10 - 5);
    const finalRotation = finalSide === 'tails' ? 180 : 0;
    const deg = baseTurns*180 + finalRotation + spinIndex*360;
    coin.style.transition = 'transform 900ms cubic-bezier(.22,.8,.2,1)';
    void coin.offsetWidth;
    coin.style.transform = `rotateY(${deg}deg) rotateZ(${tilt}deg)`;
  }

  function flip(choice){
    if (busy) return;
    setBusy(true);
    haptic('light');

    const outcome = Math.random()<0.5 ? 'heads' : 'tails';
    pending = { choice, outcome };
    spinTo(outcome);
  }

  // R√©sultat calcul√© √† la vraie fin de l'animation
  coin.addEventListener('transitionend', (e)=>{
    if (e.propertyName !== 'transform') return;
    if (!pending) { setBusy(false); return; }

    const { choice, outcome } = pending;
    pending = null;

    const win = (choice === outcome);
    if (win){
      score += 2;
      hud();
      haptic('medium');
      toastMsg(`${outcome==='heads'?'üü¶ HEADS':'üü© TAILS'} +2 pts`, 'ok');
    } else {
      toastMsg(`${outcome==='heads'?'üü¶ HEADS':'üü© TAILS'} perdu`, 'warn');
    }
    setTimeout(()=>setBusy(false), 200);
  });

  btnH.addEventListener('click', ()=>flip('heads'));
  btnT.addEventListener('click', ()=>flip('tails'));

  // --- On-Chain Functions ---
  let onchainBet = 0;
  let currentMatchId = null;
  let onchainGameState = 'idle'; // idle, created, joined, revealing, resolved
  let onchainMyChoice = null;

  async function checkWalletConnection() {
    try {
      const isConnected = await isConnected();
      if (isConnected) {
        const address = await getUserAddress();
        document.getElementById('walletAddress').textContent = `Connect√©: ${address.slice(0, 8)}...`;
        document.getElementById('connectWallet').style.display = 'none';
        document.getElementById('onchainBetSelector').style.display = 'block';
        await updateTONBalance();
      } else {
        document.getElementById('walletAddress').textContent = 'Connectez votre wallet TON';
        document.getElementById('connectWallet').style.display = 'block';
        document.getElementById('onchainBetSelector').style.display = 'none';
      }
    } catch (error) {
      console.error('Wallet check failed:', error);
    }
  }

  async function connectTONWallet() {
    try {
      const connected = await connectWallet();
      if (connected) {
        await checkWalletConnection();
        toastMsg('üîó Wallet connect√©!', 'ok');
      } else {
        toastMsg('‚ùå √âchec de connexion', 'warn');
      }
    } catch (error) {
      console.error('Connection failed:', error);
      toastMsg('‚ùå Erreur de connexion', 'warn');
    }
  }

  async function updateTONBalance() {
    try {
      // In a real app, you'd query the TON blockchain
      // For now, we'll simulate a balance
      const balance = 10.5; // Simulated balance
      document.getElementById('tonBalance').textContent = balance.toFixed(2);
    } catch (error) {
      console.error('Balance update failed:', error);
    }
  }

  function setOnchainBet(amount) {
    onchainBet = amount;
    document.querySelectorAll('#onchainBetSelector .bet-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    toastMsg(`Mise: ${amount} TON`, 'pom');
  }

  async function createOnchainMatch() {
    if (onchainBet === 0) {
      toastMsg('üí∞ Choisissez une mise d\'abord!', 'warn');
      return;
    }

    try {
      toastMsg('üéÆ Cr√©ation du match...', '');
      
      // Generate seed and commit
      const seed = generateSeed();
      const commit = await calculateCommit(seed);
      
      // Store seed for later reveal
      const matchId = Date.now();
      localStorage.setItem(`onchain_seed_${matchId}`, JSON.stringify(Array.from(seed)));
      
      // Create match on blockchain
      const betAmount = parseTON(onchainBet);
      const result = await createMatch(betAmount);
      
      currentMatchId = matchId;
      onchainGameState = 'created';
      
      // Show game room
      document.getElementById('onchainBetSelector').style.display = 'none';
      document.getElementById('onchainGameRoom').style.display = 'block';
      document.getElementById('currentMatchId').textContent = matchId;
      document.getElementById('onchainBet1').textContent = `${onchainBet} TON`;
      document.getElementById('onchainStatus').textContent = 'En attente d\'un adversaire...';
      document.getElementById('cancelBtn').style.display = 'block';
      
      toastMsg(`üéÆ Match cr√©√©! ID: ${matchId}`, 'ok');
      haptic('medium');
      
    } catch (error) {
      console.error('Create match failed:', error);
      toastMsg('‚ùå √âchec de cr√©ation du match', 'warn');
    }
  }

  function showJoinInterface() {
    document.getElementById('onchainBetSelector').style.display = 'none';
    document.getElementById('joinInterface').style.display = 'block';
  }

  function hideJoinInterface() {
    document.getElementById('joinInterface').style.display = 'none';
    document.getElementById('onchainBetSelector').style.display = 'block';
  }

  async function joinOnchainMatch() {
    const matchId = parseInt(document.getElementById('matchIdInput').value);
    if (!matchId) {
      toastMsg('üí∞ Entrez un ID de match valide!', 'warn');
      return;
    }

    try {
      toastMsg('üöÄ Rejoindre le match...', '');
      
      // Generate seed and commit
      const seed = generateSeed();
      const commit = await calculateCommit(seed);
      
      // Store seed for later reveal
      localStorage.setItem(`onchain_seed_${matchId}`, JSON.stringify(Array.from(seed)));
      
      // Join match on blockchain
      const betAmount = parseTON(onchainBet);
      const result = await joinMatch(matchId, betAmount);
      
      currentMatchId = matchId;
      onchainGameState = 'joined';
      
      // Show game room
      document.getElementById('joinInterface').style.display = 'none';
      document.getElementById('onchainGameRoom').style.display = 'block';
      document.getElementById('currentMatchId').textContent = matchId;
      document.getElementById('onchainBet2').textContent = `${onchainBet} TON`;
      document.getElementById('onchainStatus').textContent = 'Choisissez votre c√¥t√©!';
      
      toastMsg(`üöÄ Match rejoint!`, 'ok');
      haptic('medium');
      
    } catch (error) {
      console.error('Join match failed:', error);
      toastMsg('‚ùå √âchec de rejoindre le match', 'warn');
    }
  }

  async function makeOnchainChoice(choice) {
    if (onchainGameState !== 'joined') return;
    
    onchainMyChoice = choice;
    document.getElementById('onchainChoice1').textContent = choice === 'heads' ? 'üêï' : 'ü¶¥';
    document.getElementById('onchainBtnH').disabled = true;
    document.getElementById('onchainBtnT').disabled = true;
    document.getElementById('onchainStatus').textContent = 'En attente de l\'adversaire...';
    
    // Simulate opponent choice (in real app, this would come from blockchain events)
    setTimeout(async () => {
      const opponentChoice = Math.random() < 0.5 ? 'heads' : 'tails';
      document.getElementById('onchainChoice2').textContent = opponentChoice === 'heads' ? 'üêï' : 'ü¶¥';
      document.getElementById('onchainStatus').textContent = 'Lancement de la pi√®ce...';
      
      setTimeout(() => {
        flipOnchainCoin();
      }, 1000);
    }, 2000);
    
    haptic('light');
  }

  function flipOnchainCoin() {
    onchainGameState = 'revealing';
    const outcome = Math.random() < 0.5 ? 'heads' : 'tails';
    
    // Animation de la pi√®ce
    const onchainCoin = document.getElementById('onchainCoin');
    spinIndex++;
    const baseTurns = 2 + Math.floor(Math.random()*2);
    const tilt = (Math.random()*10 - 5);
    const finalRotation = outcome === 'tails' ? 180 : 0;
    const deg = baseTurns*180 + finalRotation + spinIndex*360;
    
    onchainCoin.style.transition = 'transform 900ms cubic-bezier(.22,.8,.2,1)';
    void onchainCoin.offsetWidth;
    onchainCoin.style.transform = `rotateY(${deg}deg) rotateZ(${tilt}deg)`;
    
    // Show reveal button
    document.getElementById('revealBtn').style.display = 'block';
    document.getElementById('onchainStatus').textContent = 'R√©v√©lez votre seed pour finaliser!';
    
    // Store outcome for reveal
    localStorage.setItem(`onchain_outcome_${currentMatchId}`, outcome);
  }

  async function revealOnchainSeed() {
    try {
      toastMsg('üîì R√©v√©lation du seed...', '');
      
      const result = await revealSeed(currentMatchId);
      
      // Simulate resolution (in real app, this would come from blockchain events)
      setTimeout(() => {
        const outcome = localStorage.getItem(`onchain_outcome_${currentMatchId}`);
        const iWon = (onchainMyChoice === outcome);
        
        if (iWon) {
          toastMsg(`üéâ VICTOIRE! +${onchainBet * 2} TON`, 'ok');
          haptic('heavy');
        } else {
          toastMsg(`üòî D√âFAITE! -${onchainBet} TON`, 'warn');
          haptic('light');
        }
        
        document.getElementById('onchainStatus').textContent = `${iWon ? 'VICTOIRE' : 'D√âFAITE'} - ${outcome === 'heads' ? 'HEADS' : 'TAILS'}`;
        onchainGameState = 'resolved';
        
        // Clean up
        localStorage.removeItem(`onchain_seed_${currentMatchId}`);
        localStorage.removeItem(`onchain_outcome_${currentMatchId}`);
        
        // Return to menu after 3 seconds
        setTimeout(() => {
          resetOnchainGame();
        }, 3000);
        
      }, 2000);
      
    } catch (error) {
      console.error('Reveal failed:', error);
      toastMsg('‚ùå √âchec de r√©v√©lation', 'warn');
    }
  }

  async function cancelOnchainMatch() {
    if (onchainGameState !== 'created') return;
    
    try {
      toastMsg('‚ùå Annulation du match...', '');
      
      const result = await cancelMatch(currentMatchId);
      
      toastMsg('‚úÖ Match annul√©, fonds r√©cup√©r√©s', 'ok');
      resetOnchainGame();
      
    } catch (error) {
      console.error('Cancel failed:', error);
      toastMsg('‚ùå √âchec d\'annulation', 'warn');
    }
  }

  async function claimOnchainForfeit() {
    try {
      toastMsg('üí∞ R√©cup√©ration des fonds...', '');
      
      const result = await claimForfeit(currentMatchId);
      
      toastMsg('‚úÖ Fonds r√©cup√©r√©s!', 'ok');
      resetOnchainGame();
      
    } catch (error) {
      console.error('Claim failed:', error);
      toastMsg('‚ùå √âchec de r√©cup√©ration', 'warn');
    }
  }

  function resetOnchainGame() {
    onchainGameState = 'idle';
    currentMatchId = null;
    onchainMyChoice = null;
    
    document.getElementById('onchainGameRoom').style.display = 'none';
    document.getElementById('onchainBetSelector').style.display = 'block';
    document.getElementById('onchainChoice1').textContent = '‚Äî';
    document.getElementById('onchainChoice2').textContent = '‚Äî';
    document.getElementById('onchainBtnH').disabled = false;
    document.getElementById('onchainBtnT').disabled = false;
    document.getElementById('revealBtn').style.display = 'none';
    document.getElementById('cancelBtn').style.display = 'none';
    document.getElementById('claimBtn').style.display = 'none';
    document.getElementById('onchainStatus').textContent = 'En attente...';
  }

  // Initialize
  updatePomBalance();
  
  // Initialize PvP matches when PvP mode is selected
  document.getElementById('matchSearch').addEventListener('input', renderMatchList);
  
  // Initialize matches when page loads
  setTimeout(() => {
    if (currentMode === 'pvp') {
      initializeMatches();
    }
  }, 100);
  </script>
</body>
</html>